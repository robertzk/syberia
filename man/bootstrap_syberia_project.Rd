% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/director.R
\name{bootstrap_syberia_project}
\alias{bootstrap_syberia_project}
\title{Bootstrap a syberia project by setting up its director object.}
\usage{
bootstrap_syberia_project(project)
}
\arguments{
\item{project}{director. The syberia director object to bootstrap.}
}
\description{
The initial parsers that are derived from the syberia configuration
directory (\code{"config/"}) will be added to the director object here.
In particular, the \code{"config/routes.R"} file should specify the
controllers for various resource types, which will reside in
\code{"lib/controllers"} and be simple files with one function without
any arguments. This function will have the following present
when executed:
}
\details{
\itemize{
  \item{"resource"}{The name of the resource (basically, the filename
    without the .R extension). If the resource is so-called an idempotent
    resource, then this will be the non-idempotent version. An
    idempotent resource is a file which is located in a directory whose
    name is the same as the filename without extension.

For example, \code{"models/infection/infection.R"} is an idempotent resource
    because the \code{"infection.R"} file is present in the \code{"infection"}
    directory and--ignoring file extension--they are identical. This kind of
    convention allows any file in a syberia project to have helpers functions
    that better help you structure your files. For example, if
    \code{"infection.R"} needs to reference some long list of static
    variable names, they can can be placed in \code{"models/infection/const.R"}
    and included in \code{infection.R} using the \code{define} function
    from the Ramd package.

The \code{resource} key will be the filename without its extension if it
    is not an idempotent resource (so \code{"models/airtraffic.R"} will have
    key \code{"models/airtraffic"}). On the other hand, an idempotent
    resource will have key its residing directory so
    (\code{"models/pollution/pollution.R"} will have key
    \code{"models/pollution"}).}

\item{"input"}{When an R file is sourced through the \code{base::source}
    function, it leaves a trail we can follow. This is because \code{source}
    takes a second argument \code{local} (see the documentation for
    \code{base::source}) which allows you to provide an environment in which
    all execution of a given file will occur. Thus, if we have a file
    that has the body \code{test <- 1; string <- 'hello'}, using this trick
    we can construct an environment that has \code{test = 1} and
    \code{string = 'hello'}.

The \code{input} that is available to the controller is precisely
    this environment.}

\item{"output"}{When an R file is sourced through the \code{base::source}
    function, its last executed expression is available in the return
    value's \code{$value} key. Thus, if you had a file \code{"model.R"} with code
    \code{column <- 'Sepal.Length'; lm(iris$Sepal.Width ~ iris[[column]])}
    then we can access the \code{lm} model using \code{source('model.R')$value}.

This "file return value" is precisely the \code{output} that is available
    to the controller for a resource.}

\item{"resource_body"}{The source code (as a string) of the resource is
    available as \code{resource_body} in the controller.}

\item{"director"}{The director object of the enclosing syberia project is
    available through the \code{director} local variable in controller.

For more information on this, see the \code{director} package.}

}

The \code{config/routes.R} file in your syberia project should look something
like this:

\code{list('lib/classifiers' = 'classifier',
           'data'            = 'data')}

where we have two kinds of resources: classifiers and data sources.

It is up to you how to define what these resources "do". The
\code{lib/classifiers} and \code{data} directories (in the root of your
syberia project) can have arbitrary code, and the \code{resource},
\code{input}, and \code{output} (like in the list above) are made available
to the controller.

The return value of a controller will be the final result of a user
attempting to load a resource. For example, if we had the controller
\code{"lib/controllers/classifier.R"} with:

\code{function() {
  classifier <- list(train = input$train, predict = input$predict)
  class(classifier) <- 'simpleClassifier'
  classifier
}}

then we could define a classifier object like the one generated above
by placing a \code{train} and \code{predict} function in a file
\code{"simple.R"} in the \code{lib/classifiers} directory.

Then, if we have our syberia project, say
   \code{proj <- syberia_project('some/directory')}
we could load this object with
   \code{simple_classifier <- proj$resource('lib/classifiers/simple')}
and have an object that we can call \code{simple_classifier$train(...)}
and \code{simple_classifier$predict} on.

TODO: (RK) Explain why this is better than just random files.
}

